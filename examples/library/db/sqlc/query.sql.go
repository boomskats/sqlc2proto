// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBook = `-- name: CreateBook :one
INSERT INTO books (
    title, author, isbn, published_on, page_count, genre, summary, in_stock
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, title, author, isbn, published_on, page_count, genre, summary, in_stock, added_at
`

type CreateBookParams struct {
	Title       string      `json:"title"`
	Author      string      `json:"author"`
	Isbn        string      `json:"isbn"`
	PublishedOn pgtype.Date `json:"published_on"`
	PageCount   int32       `json:"page_count"`
	Genre       string      `json:"genre"`
	Summary     pgtype.Text `json:"summary"`
	InStock     bool        `json:"in_stock"`
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (Book, error) {
	row := q.db.QueryRow(ctx, createBook,
		arg.Title,
		arg.Author,
		arg.Isbn,
		arg.PublishedOn,
		arg.PageCount,
		arg.Genre,
		arg.Summary,
		arg.InStock,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Isbn,
		&i.PublishedOn,
		&i.PageCount,
		&i.Genre,
		&i.Summary,
		&i.InStock,
		&i.AddedAt,
	)
	return i, err
}

const createLoan = `-- name: CreateLoan :one
INSERT INTO loans (
    book_id, member_id, due_date, status
) VALUES (
    $1, $2, $3, 'active'
)
RETURNING id, book_id, member_id, loan_date, due_date, returned_date, status
`

type CreateLoanParams struct {
	BookID   int32     `json:"book_id"`
	MemberID int32     `json:"member_id"`
	DueDate  time.Time `json:"due_date"`
}

func (q *Queries) CreateLoan(ctx context.Context, arg CreateLoanParams) (Loan, error) {
	row := q.db.QueryRow(ctx, createLoan, arg.BookID, arg.MemberID, arg.DueDate)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.MemberID,
		&i.LoanDate,
		&i.DueDate,
		&i.ReturnedDate,
		&i.Status,
	)
	return i, err
}

const createMember = `-- name: CreateMember :one
INSERT INTO members (
    name, email, phone, expiry_date
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, name, email, phone, join_date, expiry_date, is_active
`

type CreateMemberParams struct {
	Name       string      `json:"name"`
	Email      string      `json:"email"`
	Phone      pgtype.Text `json:"phone"`
	ExpiryDate pgtype.Date `json:"expiry_date"`
}

func (q *Queries) CreateMember(ctx context.Context, arg CreateMemberParams) (Member, error) {
	row := q.db.QueryRow(ctx, createMember,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.ExpiryDate,
	)
	var i Member
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.JoinDate,
		&i.ExpiryDate,
		&i.IsActive,
	)
	return i, err
}

const getBook = `-- name: GetBook :one
SELECT id, title, author, isbn, published_on, page_count, genre, summary, in_stock, added_at FROM books
WHERE id = $1
`

func (q *Queries) GetBook(ctx context.Context, id int32) (Book, error) {
	row := q.db.QueryRow(ctx, getBook, id)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Isbn,
		&i.PublishedOn,
		&i.PageCount,
		&i.Genre,
		&i.Summary,
		&i.InStock,
		&i.AddedAt,
	)
	return i, err
}

const getLoan = `-- name: GetLoan :one
SELECT id, book_id, member_id, loan_date, due_date, returned_date, status FROM loans
WHERE id = $1
`

func (q *Queries) GetLoan(ctx context.Context, id int32) (Loan, error) {
	row := q.db.QueryRow(ctx, getLoan, id)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.MemberID,
		&i.LoanDate,
		&i.DueDate,
		&i.ReturnedDate,
		&i.Status,
	)
	return i, err
}

const getMember = `-- name: GetMember :one
SELECT id, name, email, phone, join_date, expiry_date, is_active FROM members
WHERE id = $1
`

func (q *Queries) GetMember(ctx context.Context, id int32) (Member, error) {
	row := q.db.QueryRow(ctx, getMember, id)
	var i Member
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.JoinDate,
		&i.ExpiryDate,
		&i.IsActive,
	)
	return i, err
}

const listActiveLoansByMember = `-- name: ListActiveLoansByMember :many
SELECT id, book_id, member_id, loan_date, due_date, returned_date, status FROM loans
WHERE member_id = $1 AND status = 'active'
ORDER BY due_date
`

func (q *Queries) ListActiveLoansByMember(ctx context.Context, memberID int32) ([]Loan, error) {
	rows, err := q.db.Query(ctx, listActiveLoansByMember, memberID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Loan{}
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.MemberID,
			&i.LoanDate,
			&i.DueDate,
			&i.ReturnedDate,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooks = `-- name: ListBooks :many
SELECT id, title, author, isbn, published_on, page_count, genre, summary, in_stock, added_at FROM books
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListBooksParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListBooks(ctx context.Context, arg ListBooksParams) ([]Book, error) {
	rows, err := q.db.Query(ctx, listBooks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Book{}
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Isbn,
			&i.PublishedOn,
			&i.PageCount,
			&i.Genre,
			&i.Summary,
			&i.InStock,
			&i.AddedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMembers = `-- name: ListMembers :many
SELECT id, name, email, phone, join_date, expiry_date, is_active FROM members
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListMembersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMembers(ctx context.Context, arg ListMembersParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, listMembers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Member{}
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.JoinDate,
			&i.ExpiryDate,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnBook = `-- name: ReturnBook :one
UPDATE loans
SET returned_date = NOW(), status = 'returned'
WHERE id = $1 AND status = 'active'
RETURNING id, book_id, member_id, loan_date, due_date, returned_date, status
`

func (q *Queries) ReturnBook(ctx context.Context, id int32) (Loan, error) {
	row := q.db.QueryRow(ctx, returnBook, id)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.MemberID,
		&i.LoanDate,
		&i.DueDate,
		&i.ReturnedDate,
		&i.Status,
	)
	return i, err
}

const searchBooks = `-- name: SearchBooks :many
SELECT id, title, author, isbn, published_on, page_count, genre, summary, in_stock, added_at FROM books
WHERE 
    ($1::text IS NULL OR title ILIKE '%' || $1 || '%') AND
    ($2::text IS NULL OR author ILIKE '%' || $2 || '%') AND
    ($3::text IS NULL OR genre = $3) AND
    ($4::boolean IS NULL OR in_stock = $4)
ORDER BY title
LIMIT $5 OFFSET $6
`

type SearchBooksParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Column4 bool   `json:"column_4"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) SearchBooks(ctx context.Context, arg SearchBooksParams) ([]Book, error) {
	rows, err := q.db.Query(ctx, searchBooks,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Book{}
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Isbn,
			&i.PublishedOn,
			&i.PageCount,
			&i.Genre,
			&i.Summary,
			&i.InStock,
			&i.AddedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
